import pandas as pd
import numpy as np
import ta
from typing import Tuple, Dict, Union, List

class TechnicalIndicators:
    """
    Agregador completo de indicadores técnicos, contexto enriquecido:
    - Indicadores clássicos e modernos
    - Ratings, zonas, tendências, contexto (sempre dicts!)
    - Pronto para ML, ensemble e dashboards
    """

    # ==== Indicadores Clássicos ====

    @staticmethod
    def calc_rsi(close: pd.Series, period: int = 14) -> Dict[str, Union[float, str]]:
        if len(close) < period:
            return {'error': 'Not enough data'}
        rsi = ta.momentum.RSIIndicator(close, window=period).rsi()
        val = float(rsi.iloc[-1])
        prev = float(rsi.iloc[-2]) if len(rsi) > 1 else val
        return {
            'value': round(val, 2),
            'zone': 'overbought' if val > 70 else 'oversold' if val < 30 else 'neutral',
            'trend': 'up' if val > prev else 'down'
        }

    @staticmethod
    def calc_macd(close: pd.Series, fast: int = 12, slow: int = 26, signal: int = 9) -> Dict[str, Union[float, str]]:
        macd = ta.trend.MACD(close, window_fast=fast, window_slow=slow, window_sign=signal)
        hist = float(macd.macd_diff().iloc[-1])
        macd_line = float(macd.macd().iloc[-1])
        signal_line = float(macd.macd_signal().iloc[-1])
        return {
            'histogram': round(hist, 5),
            'macd_line': round(macd_line, 5),
            'signal_line': round(signal_line, 5),
            'momentum': 'bullish' if hist > 0 else 'bearish',
            'cross': 'bullish' if macd_line > signal_line else 'bearish' if macd_line < signal_line else 'neutral'
        }

    @staticmethod
    def calc_bollinger(close: pd.Series, period: int = 20, std_dev: int = 2) -> Dict[str, Union[float, str]]:
        bb = ta.volatility.BollingerBands(close, window=period, window_dev=std_dev)
        upper = float(bb.bollinger_hband().iloc[-1])
        lower = float(bb.bollinger_lband().iloc[-1])
        width = float(bb.bollinger_wband().iloc[-1])
        percent_b = float(bb.bollinger_pband().iloc[-1])
        pos = 'squeeze' if width < 0.5 else 'normal'
        price_pos = 'above_upper' if close.iloc[-1] > upper else \
                    'below_lower' if close.iloc[-1] < lower else \
                    'inside'
        return {
            'upper': round(upper, 5),
            'lower': round(lower, 5),
            'width': round(width, 5),
            'percent_b': round(percent_b, 5),
            'position': pos,
            'price_position': price_pos
        }

    @staticmethod
    def calc_atr(high: pd.Series, low: pd.Series, close: pd.Series, period: int = 14) -> Dict[str, Union[float, str]]:
        atr = ta.volatility.AverageTrueRange(high, low, close, window=period)
        series = atr.average_true_range()
        curr = float(series.iloc[-1])
        prev = float(series.iloc[-2]) if len(series) > 1 else curr
        return {
            'value': round(curr, 5),
            'ratio': round(curr / close.iloc[-1] * 100, 2),
            'trend': 'rising' if curr > prev else 'falling'
        }

    @staticmethod
    def calc_adx(high: pd.Series, low: pd.Series, close: pd.Series, period: int = 14) -> Dict[str, Union[float, str]]:
        adx = ta.trend.ADXIndicator(high, low, close, window=period)
        val = float(adx.adx().iloc[-1])
        di_plus = float(adx.adx_pos().iloc[-1])
        di_minus = float(adx.adx_neg().iloc[-1])
        return {
            'adx': round(val, 2),
            'di_plus': round(di_plus, 2),
            'di_minus': round(di_minus, 2),
            'strength': 'strong' if val > 25 else 'weak',
            'trend': 'up' if di_plus > di_minus else 'down'
        }

    # ==== Indicadores Avançados ====

    @staticmethod
    def calc_ichimoku(high: pd.Series, low: pd.Series, close: pd.Series) -> Dict[str, Union[float, str]]:
        ichi = ta.trend.IchimokuIndicator(high, low)
        conv = float(ichi.ichimoku_conversion_line().iloc[-1])
        base = float(ichi.ichimoku_base_line().iloc[-1])
        a = float(ichi.ichimoku_a().iloc[-1])
        b = float(ichi.ichimoku_b().iloc[-1])
        cloud_pos = 'above' if close.iloc[-1] > max(a, b) else 'below' if close.iloc[-1] < min(a, b) else 'inside'
        return {
            'conversion': round(conv, 5),
            'base': round(base, 5),
            'leading_a': round(a, 5),
            'leading_b': round(b, 5),
            'cloud_position': cloud_pos
        }

    @staticmethod
    def calc_fibonacci(high: pd.Series, low: pd.Series) -> Dict[str, float]:
        diff = high.max() - low.min()
        return {
            '23.6%': round(high.max() - diff * 0.236, 5),
            '38.2%': round(high.max() - diff * 0.382, 5),
            '50%': round(high.max() - diff * 0.5, 5),
            '61.8%': round(high.max() - diff * 0.618, 5)
        }

    @staticmethod
    def calc_supertrend(high: pd.Series, low: pd.Series, close: pd.Series, period: int = 7, multiplier: int = 3) -> Dict[str, Union[float, str, bool]]:
        st = ta.trend.SuperTrendIndicator(high, low, close, window=period, multiplier=multiplier)
        last = int(st.super_trend_direction().iloc[-1])
        prev = int(st.super_trend_direction().iloc[-2]) if len(st.super_trend_direction()) > 1 else last
        return {
            'value': round(float(st.super_trend().iloc[-1]), 5),
            'direction': 'up' if last == 1 else 'down',
            'changed': last != prev
        }

    @staticmethod
    def get_market_profile(close: pd.Series, volume: pd.Series, bins: int = 20) -> Dict[str, float]:
        hist, bin_edges = np.histogram(close, bins=bins, weights=volume)
        area_idx = np.argsort(hist)[-3:]
        return {
            'poc': round(bin_edges[np.argmax(hist)], 5),
            'value_area': {
                'low': round(bin_edges[min(area_idx)], 5),
                'high': round(bin_edges[max(area_idx)], 5)
            }
        }

    # ==== Novos Indicadores ====

    @staticmethod
    def calc_stochastic(high: pd.Series, low: pd.Series, close: pd.Series, k_period: int = 14, d_period: int = 3) -> Dict[str, Union[float, str]]:
        stoch = ta.momentum.StochasticOscillator(high=high, low=low, close=close, window=k_period, smooth_window=d_period)
        k = float(stoch.stoch().iloc[-1])
        d = float(stoch.stoch_signal().iloc[-1])
        return {
            'k': round(k, 2),
            'd': round(d, 2),
            'state': 'overbought' if k > 80 else 'oversold' if k < 20 else 'neutral',
            'trend': 'up' if k > d else 'down'
        }

    @staticmethod
    def calc_cci(high: pd.Series, low: pd.Series, close: pd.Series, period: int = 20) -> Dict[str, Union[float, str]]:
        cci = ta.trend.CCIIndicator(high=high, low=low, close=close, window=period)
        val = float(cci.cci().iloc[-1])
        return {
            'value': round(val, 2),
            'state': 'overbought' if val > 100 else 'oversold' if val < -100 else 'neutral'
        }

    @staticmethod
    def calc_williams_r(high: pd.Series, low: pd.Series, close: pd.Series, period: int = 14) -> Dict[str, Union[float, str]]:
        will = ta.momentum.WilliamsRIndicator(high=high, low=low, close=close, lbp=period)
        val = float(will.williams_r().iloc[-1])
        return {
            'value': round(val, 2),
            'state': 'overbought' if val > -20 else 'oversold' if val < -80 else 'neutral'
        }

    @staticmethod
    def calc_parabolic_sar(high: pd.Series, low: pd.Series, step: float = 0.02, max_step: float = 0.2) -> Dict[str, Union[float, str]]:
        psar = ta.trend.PSARIndicator(high=high, low=low, close=(high + low)/2, step=step, max_step=max_step)
        val = float(psar.psar().iloc[-1])
        return {
            'value': round(val, 5),
            'trend': 'up' if val < high.iloc[-1] else 'down'
        }

    @staticmethod
    def calc_momentum(close: pd.Series, period: int = 10) -> Dict[str, Union[float, str]]:
        mom = ta.momentum.ROCIndicator(close=close, window=period)
        val = float(mom.roc().iloc[-1])
        return {
            'value': round(val, 5),
            'trend': 'up' if val > 0 else 'down'
        }

    @staticmethod
    def calc_roc(close: pd.Series, period: int = 12) -> Dict[str, Union[float, str]]:
        roc = ta.momentum.ROCIndicator(close=close, window=period)
        val = float(roc.roc().iloc[-1])
        return {
            'value': round(val, 5),
            'trend': 'up' if val > 0 else 'down'
        }

    @staticmethod
    def calc_dmi(high: pd.Series, low: pd.Series, close: pd.Series, period: int = 14) -> Dict[str, Union[float, str]]:
        dmi = ta.trend.DMIIndicator(high=high, low=low, close=close, window=period)
        plus = float(dmi.plus_di().iloc[-1])
        minus = float(dmi.minus_di().iloc[-1])
        adx = float(dmi.adx().iloc[-1])
        return {
            'plus_di': round(plus, 2),
            'minus_di': round(minus, 2),
            'adx': round(adx, 2),
            'trend': 'up' if plus > minus else 'down'
        }

    @staticmethod
    def calc_vwap(high: pd.Series, low: pd.Series, close: pd.Series, volume: pd.Series) -> Dict[str, Union[float, str]]:
        typical_price = (high + low + close) / 3
        vwap = (typical_price * volume).cumsum() / volume.cumsum()
        val = float(vwap.iloc[-1])
        return {
            'value': round(val, 5),
            'relation': 'above' if close.iloc[-1] > val else 'below'
        }

    @staticmethod
    def calc_envelope(close: pd.Series, period: int = 20, deviation: float = 0.05) -> Dict[str, Union[float, str]]:
        sma = close.rolling(window=period).mean()
        base = float(sma.iloc[-1])
        upper = base * (1 + deviation)
        lower = base * (1 - deviation)
        pos = 'above' if close.iloc[-1] > upper else 'below' if close.iloc[-1] < lower else 'within'
        return {
            'upper': round(upper, 5),
            'lower': round(lower, 5),
            'center': round(base, 5),
            'position': pos
        }

    @staticmethod
    def calc_zigzag(close: pd.Series, percent: float = 5) -> Dict[str, Union[List[float], str]]:
        peaks = []
        troughs = []
        last_pivot = close.iloc[0]
        trend = None
        for i in range(1, len(close)):
            if close.iloc[i] >= last_pivot * (1 + percent/100):
                if trend != 'up':
                    troughs.append(float(last_pivot))
                    trend = 'up'
                last_pivot = close.iloc[i]
            elif close.iloc[i] <= last_pivot * (1 - percent/100):
                if trend != 'down':
                    peaks.append(float(last_pivot))
                    trend = 'down'
                last_pivot = close.iloc[i]
        return {
            'peaks': peaks[-3:],
            'troughs': troughs[-3:],
            'trend': trend
        }

    @staticmethod
    def calc_elliott_wave(close: pd.Series, lookback: int = 50) -> Dict[str, Union[str, List[float]]]:
        if len(close) < lookback:
            return {'error': 'Not enough data'}
        window = close.iloc[-lookback:]
        peaks = window[(window.shift(1) < window) & (window.shift(-1) < window)]
        troughs = window[(window.shift(1) > window) & (window.shift(-1) > window)]
        return {
            'peaks': [float(p) for p in peaks.tolist()],
            'troughs': [float(t) for t in troughs.tolist()],
            'phase': 'impulse' if len(peaks) >= 3 else 'correction'
        }

    # ==== Ratings/Auxiliares (sempre dict!) ====

    @staticmethod
    def calc_moving_averages(close: pd.Series, fast: int = 5, slow: int = 20) -> Dict[str, str]:
        fast_ma = close.rolling(window=fast).mean().iloc[-1]
        slow_ma = close.rolling(window=slow).mean().iloc[-1]
        if fast_ma > slow_ma:
            return {"rating": "buy"}
        elif fast_ma < slow_ma:
            return {"rating": "sell"}
        else:
            return {"rating": "neutral"}

    @staticmethod
    def calc_oscillators(rsi: float, macd_hist: float) -> Dict[str, str]:
        if rsi > 70 and macd_hist < 0:
            return {"rating": "sell"}
        elif rsi < 30 and macd_hist > 0:
            return {"rating": "buy"}
        else:
            return {"rating": "neutral"}

    @staticmethod
    def calc_volatility(close: pd.Series, period: int = 14) -> Dict[str, str]:
        std = close.rolling(window=period).std().iloc[-1]
        median_std = close.rolling(window=period).std().median()
        return {"level": "High" if std > median_std else "Low"}

    @staticmethod
    def calc_volume_status(volume: pd.Series, period: int = 20) -> Dict[str, str]:
        ma = volume.rolling(window=period).mean().iloc[-1]
        if volume.iloc[-1] > ma * 1.5:
            return {"status": "Spiked"}
        elif volume.iloc[-1] < ma * 0.7:
            return {"status": "Low"}
        else:
            return {"status": "Normal"}

    @staticmethod
    def calc_sentiment(close: pd.Series) -> Dict[str, str]:
        if len(close) < 3:
            return {"sentiment": "Neutral"}
        if close.iloc[-1] > close.iloc[-2] > close.iloc[-3]:
            return {"sentiment": "Optimistic"}
        elif close.iloc[-1] < close.iloc[-2] < close.iloc[-3]:
            return {"sentiment": "Pessimistic"}
        else:
            return {"sentiment": "Neutral"}

    # ==== Funções auxiliares enriquecidas ====

    @staticmethod
    def get_trend_strength(close: pd.Series, period: int = 14) -> Dict[str, Union[int, str]]:
        rsi = TechnicalIndicators.calc_rsi(close, period)
        adx = TechnicalIndicators.calc_adx(close, close, close, period)
        mom = TechnicalIndicators.calc_momentum(close, period)
        score = 0
        if rsi.get("value", 50) > 60: score += 1
        elif rsi.get("value", 50) < 40: score -= 1
        if adx.get("adx", 20) > 25: score += 2
        elif adx.get("adx", 20) < 20: score -= 1
        if mom.get("trend", "up") == 'up': score += 1
        else: score -= 1
        return {
            'score': score,
            'strength': 'strong' if score >= 3 else 'moderate' if score >= 1 else 'weak' if score >= -1 else 'bearish'
        }

    @staticmethod
    def get_support_resistance(close: pd.Series, lookback: int = 100) -> Dict[str, Union[str, List[float]]]:
        if len(close) < lookback:
            return {'error': 'Not enough data'}
        window = close.iloc[-lookback:]
        resistance = window.rolling(5).max().dropna().unique()
        support = window.rolling(5).min().dropna().unique()
        return {
            'support': sorted([float(x) for x in support])[-3:],
            'resistance': sorted([float(x) for x in resistance])[:3]
        }
